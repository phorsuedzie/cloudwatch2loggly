'use strict';

var parseLine = function(line) {
  var tokens = [];
  var start = 0;
  var quoted = false;
  var escaped = false;
  for (var i = 0; i < line.length; i++) {
    var c = line.charAt(i);
    if (quoted) {
      if (escaped) {
        escaped = false;
      } else if (c === '\\') {
        escaped = true;
      } else if (c === '"') {
        quoted = false;
        tokens.push(line.substring(start, i));
        start = i + 1;
      }
    } else if (c === " ") {
      if (i !== start) {
        tokens.push(line.substring(start, i));
      }
      start = i + 1;
    } else if (i === start && c === '"') {
      quoted = true;
      escaped = false;
      start = i + 1;
    }
  }
  if (start != line.length) {
    tokens.push(line.substring(start));
  }
  return tokens;
};

var populateDataWithHttpStatus = function(data, http_status_code, target_status_code) {
  data.target_status_code = target_status_code;
  var http_status = Number.parseInt(http_status_code);
  if (http_status.toString() === http_status_code) {
    data.http_status = http_status;
  } else {
    if (http_status_code !== target_status_code) {
      data.http_status_code = http_status_code;
    }
  }
  return data;
}

var handleELBTokens = function(tokens) {
  var client_address = tokens[2].split(":");
  var backend_address = tokens[3].split(":");
  var request_info = tokens[11].split(" ");
  var request_url_components = request_info[1].split("?");
  var http_status_code = tokens[7];
  var target_status_code = tokens[8];
  var data = {
    timestamp: tokens[0],
    elb: tokens[1],
    client_ip: client_address[0],
    client_port: client_address[1],
    backend: backend_address[0],
    backend_port: backend_address[1] || "-",
    request_processing_time: parseFloat(tokens[4]),
    backend_processing_time: parseFloat(tokens[5]),
    response_processing_time: parseFloat(tokens[6]),
    received_bytes: parseFloat(tokens[9]),
    sent_bytes: parseFloat(tokens[10]),
    request_method: request_info[0],
    request_url: request_url_components[0],
    request_query_params: request_url_components[1] || "",
    user_agent: tokens[12],
    ssl_cipher: tokens[13],
    ssl_protocol: tokens[14],
  };
  populateDataWithHttpStatus(data, http_status_code, target_status_code);
  return data;
};

var handleALBTokens = function(tokens) {
  var type = tokens[0];
  var timestamp = tokens[1];
  var alb = tokens[2];

  var client_address = tokens[3].split(":");
  var client_ip = client_address[0];
  var client_port = client_address[1];

  var target_address = tokens[4].split(":");
  var target = target_address[0];
  var target_port = target_address[1];

  var request_processing_time = parseFloat(tokens[5]);
  var target_processing_time = parseFloat(tokens[6]);
  var response_processing_time = parseFloat(tokens[7]);
  var http_status_code = tokens[8];
  var target_status_code = tokens[9];
  var received_bytes = parseFloat(tokens[10]);
  var sent_bytes = parseFloat(tokens[11]);

  var request_info = tokens[12].split(" ");
  var request_method = request_info[0];
  var request_url_components = request_info[1].split("?");
  var request_url = request_url_components[0];
  var request_query_params = request_url_components[1];

  var user_agent = tokens[13];
  var ssl_cipher = tokens[14];
  var ssl_protocol = tokens[15];
  var target_group_arn = tokens[16];
  var trace_id = tokens[17];
  var hostname = tokens.length > 18 && tokens[18];
  var certificate_arn = tokens.length > 19 && tokens[19];
  var data = {
    type: type,
    timestamp: timestamp,
    alb: alb,
    client_ip: client_ip,
    client_port: client_port,
    target: target,
    // target_port: see below
    request_processing_time: request_processing_time,
    target_processing_time: target_processing_time,
    response_processing_time: response_processing_time,
    received_bytes: received_bytes,
    sent_bytes: sent_bytes,
    request_method: request_method,
    request_url: request_url,
    // request_query_params: see below
    user_agent: user_agent,
    ssl_cipher: ssl_cipher,
    ssl_protocol: ssl_protocol,
    target_group_arn: target_group_arn,
    trace_id: trace_id,
  };
  if (target_port) {
    data.target_port = target_port;
  }
  if (request_query_params) {
    data.request_query_params = request_query_params;
  }
  if (hostname) {
    data.hostname = hostname;
  }
  if (certificate_arn) {
    data.certificate_arn = certificate_arn;
  }
  populateDataWithHttpStatus(data, http_status_code, target_status_code);
  return data;
};

var handleUnknownTokens = function(tokens) {
  return {
    error: {
      message: 'unrecognized ELB log line',
    },
    tokens: tokens,
  };
};
const S3LogParser = {
  parse: (logData) => {
    return logData.trim().split("\n").map(parseLine).map((tokens) => {
      var handler;
      if (tokens.length === 15) {
        handler = handleELBTokens;
      } else if (tokens.length === 18 || tokens.length === 20) {
        handler = handleALBTokens;
      } else {
        handler = handleUnknownTokens;
      }
      return handler(tokens);
    });
  }
};

module.exports = S3LogParser;
