'use strict';

var parseLine = function(line) {
  var tokens = [];
  var start = 0;
  var quoted = false;
  var escaped = false;
  for (var i = 0; i < line.length; i++) {
    var c = line.charAt(i);
    if (quoted) {
      if (escaped) {
        escaped = false;
      } else if (c == '\\') {
        escaped = true;
      } else if (c == '"') {
        quoted = false;
        tokens.push(line.substring(start, i));
        start = i + 1;
      }
    } else if (c == " ") {
      if (i != start) {
        tokens.push(line.substring(start, i));
      }
      start = i + 1;
    } else if (i == start && c == '"') {
      quoted = true;
      escaped = false;
      start = i + 1;
    }
  }
  if (start != line.length) {
    tokens.push(line.substring(start));
  }
  return tokens;
};

var handleELBTokens = function(tokens) {
  var client_address = tokens[2].split(":");
  var backend_address = tokens[3].split(":");
  var request_info = tokens[11].split(" ");
  var request_url_components = request_info[1].split("?");
  return {
    timestamp: tokens[0],
    elb: tokens[1],
    client_ip: client_address[0],
    client_port: client_address[1],
    backend: backend_address[0],
    backend_port: backend_address[1] || "-",
    request_processing_time: parseFloat(tokens[4]),
    backend_processing_time: parseFloat(tokens[5]),
    response_processing_time: parseFloat(tokens[6]),
    elb_status_code: tokens[7],
    backend_status_code: tokens[8],
    received_bytes: parseFloat(tokens[9]),
    sent_bytes: parseFloat(tokens[10]),
    request_method: request_info[0],
    request_url: request_url_components[0],
    request_query_params: request_url_components[1] || "",
    user_agent: tokens[12],
    ssl_cipher: tokens[13],
    ssl_protocol: tokens[14],
  };
};

var handleALBTokens = function(tokens) {
  var client_address = tokens[3].split(":");
  var target_address = tokens[4].split(":");
  var request_info = tokens[12].split(" ");
  var request_url_components = request_info[1].split("?");
  return {
    type: tokens[0],
    timestamp: tokens[1],
    elb: tokens[2],
    client_ip: client_address[0],
    client_port: client_address[1],
    target: target_address[0],
    target_port: target_address[1] || "-",
    request_processing_time: parseFloat(tokens[5]),
    target_processing_time: parseFloat(tokens[6]),
    response_processing_time: parseFloat(tokens[7]),
    elb_status_code: tokens[8],
    target_status_code: tokens[9],
    received_bytes: parseFloat(tokens[10]),
    sent_bytes: parseFloat(tokens[11]),
    request_method: request_info[0],
    request_url: request_url_components[0],
    request_query_params: request_url_components[1] || "",
    user_agent: tokens[13],
    ssl_cipher: tokens[14],
    ssl_protocol: tokens[15],
    target_group_arn: tokens[16],
    trace_id: tokens[17],
  };
};

var handleUnknownTokens = function(tokens) {
  return {
    error: {
      message: 'unrecognized ELB log line',
    },
    tokens: tokens,
  };
};

const S3LogParser = {
  parse: (logData) => {
    return logData.trim().split("\n").map(parseLine).map((tokens) => {
      var handler;
      if (tokens.length == 15) {
        handler = handleELBTokens;
      } else if (tokens.length == 18) {
        handler = handleALBTokens;
      } else {
        handler = handleUnknownTokens;
      }
      return handler(tokens);
    });
  }
};

module.exports = S3LogParser;
